# Unit testing for the Discrete-Event Simulation (DES) Model.
#
# Unit tests are a type of functional testing that focuses on individual
# components (e.g. functions) and tests them in isolation to ensure they
# work as intended.
#
# In some cases, we check for a specific error message. This is because the
# test could otherwise pass with any error (and not necessarily the specific
# error we are checking for).


patrick::with_parameters_test_that(
  "the model produces an error for invalid inputs",
  {
    # Create parameter list, with the modified input
    param <- do.call(parameters, setNames(list(param_value), param_name))

    # Construct expected error message
    expected_message <- if (rule == "p") {
      sprintf('The parameter "%s" must be greater than 0.', param_name)
    } else {
      sprintf(
        'The parameter "%s" must be an integer greater than or equal to 0.',
        param_name
      )
    }

    # Verify that attempting to run the model raises the correct error message
    expect_error(model(param = param, run_number = 0L), expected_message)
  },
  patrick::cases(
    # Parameters which should be positive (p)
    list(param_name = "patient_inter", param_value = 0L, rule = "p"),
    list(param_name = "mean_n_consult_time", param_value = 0L, rule = "p"),
    list(param_name = "number_of_runs", param_value = 0L, rule = "p"),
    # Parameters which should be non-negative integers (n)
    list(param_name = "number_of_nurses", param_value = -1L, rule = "n"),
    list(param_name = "warm_up_period", param_value = -1L, rule = "n"),
    list(param_name = "data_collection_period", param_value = -1L, rule = "n")
  )
)

test_that("the model produces an error if a new parameter name is used", {
  # Add new parameter to list generated by function
  param <- parameters()
  param[["new_entry"]] <- 3L

  # Check it fails with the anticipated error message
  expect_error(model(run_number = 1L, param = param), "Extra keys: new_entry.")
})


test_that("the model produces an error if parameters are missing", {
  # Remove a parameter
  param <- parameters()
  param <- within(param, rm("patient_inter"))

  # Check it fails with the anticipated error message
  expect_error(model(run_number = 1L, param = param),
               "Missing keys: patient_inter")
})


test_that("warm-up filtering works as expected", {
  mock_result <- list(
    arrivals = data.frame(name = c("p1", "p2", "p3"),
                          start_time = c(5L, 10L, 14L),
                          stringsAsFactors = FALSE),
    resources = data.frame(resource = "nurse",
                           time = c(5L, 14L),
                           stringsAsFactors = FALSE)
  )

  # With no warm-up...
  # > Check that no entries are removed
  no_warm_up <- filter_warmup(mock_result, warm_up_period = 0L)
  expect_identical(no_warm_up, mock_result)

  # With warm-up of 10...
  # > Check that two arrivals remain (10 + 15)
  # > Check that resources starts from time 10
  filtered <- filter_warmup(mock_result, warm_up_period = 10L)
  expect_identical(nrow(filtered[["arrivals"]]), 2L)
  expect_true(all(filtered[["arrivals"]][["start_time"]] >= 10L))
  expect_identical(nrow(filtered[["resources"]]), 2L)
  expect_identical(filtered[["resources"]][["time"]], c(10L, 14L))

  # Emulating run with no data collection period...
  # > Check that no data remains
  full_length <- filter_warmup(mock_result, warm_up_period = 15L)
  expect_identical(nrow(full_length[["arrivals"]]), 0L)
  expect_identical(nrow(full_length[["resources"]]), 0L)

  # If warm-up ends before any resources are used...
  # > Check that no entries are removed from arrivals
  # > Check that no rows are add to resources (as no need for the first row to
  # equal warm_up_period if no active resources).
  short_warm_up <- filter_warmup(mock_result, warm_up_period = 3L)
  expect_identical(as.data.frame(short_warm_up[["arrivals"]]),
                   mock_result[["arrivals"]])
  expect_identical(short_warm_up[["resources"]], mock_result[["resources"]])
})


test_that("parallel processing runs successfully", {

  # Mock simulation model function so it can run without other dependencies
  # This will allows us to execute runner, but when it calls model(), instead
  # of attempting to run a simulation, it will just return a list of dataframes
  test_model <- function(run_number, param, set_seed) {
    list(
      arrivals = data.frame(run = run_number, value = rnorm(1L)),
      resources = data.frame(run = run_number, value = rnorm(1L)),
      run_results = data.frame(run = run_number, success = TRUE)
    )
  }
  mockery::stub(runner, "simulation::model", test_model)
  param <- list(cores = 2L, number_of_runs = 5L)

  # Attempt parallel processing
  result <- tryCatch({
    runner(param, use_future_seeding = TRUE)
  }, error = function(e) {
    # Check if this is a parallel processing error
    if (grepl("Failed to find a functional cluster workers|FutureError",
              e$message)) {
      # Skip test on macOS if parallel processing fails
      if (Sys.info()[["sysname"]] == "Darwin") {
        skip(paste("Parallel processing not available on this macOS system",
                   "- this is expected in CI environments"))
      }
      # Else throw an error
      stop(e, call. = FALSE)
    } else {
      # Re-throw if it's a different error
      stop(e, call. = FALSE)
    }
  })

  # Check if results contain expected structure
  expect_true("arrivals" %in% names(result))
  expect_true("resources" %in% names(result))
  expect_true("run_results" %in% names(result))

  # Ensure results have 5 runs worth of data
  expect_identical(nrow(result$arrivals), 5L)
  expect_identical(nrow(result$resources), 5L)
  expect_identical(nrow(result$run_results), 5L)
})
